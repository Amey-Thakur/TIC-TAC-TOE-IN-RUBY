<!DOCTYPE html>
<html>

<head>
    <title>Tic Tac Toe in Ruby | Amey & Mega</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/png" href="docs/Ruby%20Logo.png" />

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/css/xterm.css" />
    <script src="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@xterm/addon-fit@0.10.0/lib/addon-fit.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@ruby/3.3-wasm-wasi@2.6.0/dist/browser.script.iife.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #fff;
            font-family: monospace;
        }

        #terminal {
            width: 100%;
            height: 100%;
            display: none;
            /* Hidden until loaded */
        }

        #status {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            max-width: 80%;
        }

        .error {
            color: #ff5555;
            background: #330000;
            padding: 10px;
            border: 1px solid #ff0000;
            margin-top: 20px;
            white-space: pre-wrap;
            text-align: left;
        }

        #log {
            margin-top: 1em;
            font-size: 0.9em;
            opacity: 0.8;
            max-height: 200px;
            overflow-y: auto;
            text-align: left;
        }
    </style>
</head>

<body>
    <div id="status">
        <h1>Initializing System...</h1>
        <div id="log"></div>
    </div>
    <div id="terminal"></div>
    <script>
        const logDiv = document.getElementById("log");
        function log(msg, isError = false) {
            const div = document.createElement("div");
            div.textContent = `> ${msg}`;
            if (isError) {
                div.style.color = "#ff5555";
                console.error(msg);
            } else {
                console.log(msg);
            }
            logDiv.appendChild(div);
        }

        window.onerror = function (msg, url, lineNo, columnNo, error) {
            log(`Global Error: ${msg} (${lineNo}:${columnNo})`, true);
            return false;
        };

        const start = async () => {
            try {
                log("Checking dependencies...");
                if (!window.Terminal) throw new Error("xterm.js not loaded");
                if (!window.FitAddon) throw new Error("xterm-addon-fit not loaded");
                if (!window["ruby-wasm-wasi"]) throw new Error("ruby-wasm-wasi not loaded");

                log("Starting Terminal...");
                const term = new Terminal({
                    cursorBlink: true,
                    fontFamily: 'Menlo, Monaco, "Courier New", monospace',
                    fontSize: 18,
                    theme: { background: '#000000', foreground: '#f0f0f0' }
                });

                const fitAddon = new FitAddon.FitAddon();
                term.loadAddon(fitAddon);

                // Open terminal but verify it works
                const terminalContainer = document.getElementById("terminal");
                term.open(terminalContainer);
                fitAddon.fit();
                window.addEventListener('resize', () => fitAddon.fit());

                term.write("Loading Ruby VM...\r\n");

                log("Fetching Ruby WASM...");
                const { DefaultRubyVM } = window["ruby-wasm-wasi"];
                const response = await fetch(
                    "https://cdn.jsdelivr.net/npm/@ruby/3.3-wasm-wasi@2.6.0/dist/ruby+stdlib.wasm"
                );
                if (!response.ok) throw new Error(`Failed to fetch WASM: ${response.statusText}`);

                const buffer = await response.arrayBuffer();
                const module = await WebAssembly.compile(buffer);
                const { vm } = await DefaultRubyVM(module);

                term.write("Fetching source files...\r\n");
                log("Fetching source files...");

                // URL Encoded paths because they are on the server
                const files = [
                    "Source%20Code/TicTacToe/lib/main.rb",
                    "Source%20Code/TicTacToe/lib/game.rb",
                    "Source%20Code/TicTacToe/lib/board.rb",
                    "Source%20Code/TicTacToe/lib/player.rb",
                    "Source%20Code/TicTacToe/lib/display.rb"
                ];

                vm.eval(`require "fileutils"; FileUtils.mkdir_p("/src")`);

                for (const fileUrl of files) {
                    const fileName = decodeURIComponent(fileUrl).split('/').pop();
                    // term.write(`Loading ${fileName}...\r\n`);
                    const res = await fetch(fileUrl);
                    if (!res.ok) {
                        throw new Error(`Failed to fetch ${fileUrl} (Status: ${res.status})`);
                    }
                    const content = await res.text();
                    // Safe injection: escape backslashes, backticks, and interpolation
                    const safeContent = content.replace(/\\/g, '\\\\').replace(/`/g, '\\`').replace(/\$\{/g, '\\${').replace(/#\{/g, '\\#{');

                    // Write to VFS
                    vm.eval(`
                  File.write("/src/${fileName}", <<~'RUBY_EOF'
${safeContent}
RUBY_EOF
)
                `);
                }

                // If we got here, everything loaded. Swap views.
                document.getElementById("status").style.display = "none";
                terminalContainer.style.display = "block";
                fitAddon.fit(); // Refit now that it is visible

                term.clear();
                term.write("Welcome to Tic Tac Toe! (Powered by Ruby.wasm)\r\n");
                term.write("----------------------------------------------\r\n");
                term.write("NOTE: Input is handled via browser prompt.\r\n");
                term.write("----------------------------------------------\r\n\r\n");

                // I/O Override
                vm.eval(`
                require "js"
                module Kernel
                    def gets
                        input = JS.global.call(:prompt, "Your Move:")
                        if input == JS::Null || input == nil
                             return "exit\\n"
                        end
                        # Echo to terminal
                        JS.global[:term].call(:write, input.to_s + "\\r\\n")
                        input.to_s + "\\n"
                    end
                end
                class JSStdout
                    def write(str)
                        # Simple pass-through, xterm handles ANSI
                        clean = str.to_s.gsub("\\n", "\\r\\n")
                        JS.global[:term].call(:write, clean)
                    end
                end
                $stdout = JSStdout.new
                $stderr = JSStdout.new
            `);

                window.term = term;

                vm.eval(`Dir.chdir("/src"); load "main.rb"`);

            } catch (e) {
                log(e.message, true);
                // Ensure status is visible if there's an error and terminal isn't ready
                const statusDiv = document.getElementById("status");
                if (statusDiv.style.display === "none") {
                    // If terminal was already shown, print error there too
                    if (window.term) {
                        window.term.write(`\r\nCRITICAL ERROR: ${e.message}\r\n`);
                    } else {
                        statusDiv.style.display = "block";
                        document.getElementById("terminal").style.display = "none";
                    }
                }
            }
        };

        start();
    </script>
</body>

</html>